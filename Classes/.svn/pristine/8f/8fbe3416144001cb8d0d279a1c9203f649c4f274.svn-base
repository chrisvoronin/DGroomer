//
//  ServiceViewController.m
//  PSA
//
//  Created by Michael Simone on 3/5/09.
//  Copyright Dropped Pin 2009. All rights reserved.
//

#import "ServiceViewController.h"
#import "Service.h"

@implementation ServiceViewController

@synthesize listContent, groupListContent, savedContent;
@synthesize myTableView, mySearchBar;
@synthesize appDelegate, groupController, apptController, groups, rdControl;

static ServiceViewController *_sharedServiceViewController = nil;

+ (ServiceViewController *) ServiceViewSharedController
{
    if (!_sharedServiceViewController)
        _sharedServiceViewController = [[[self class] alloc] init];
    return _sharedServiceViewController;
}

- (IBAction)cancel:(id)sender {
	[self.view removeFromSuperview];
}

- (IBAction)addService:(id)sender {
	// Load the service detail NIB file
	if (groupController == nil) {
		groupController = [[ServiceDetailController alloc] initWithNibName:@"ServiceDetailView" bundle:[NSBundle mainBundle]];
		groupController.serviceController = self;
	}
	
	[self.view addSubview:groupController.view];
}

- (void)loadServiceList {
	
#ifdef OLD
	else {
		NSMutableArray *newArray;
		
		newArray = [[NSMutableArray alloc] init];
		
		for (int i = 0; i < [appDelegate.groups count]; i++) {
			groups = [appDelegate.groups objectAtIndex:i];
			[newArray addObject:[NSString stringWithFormat:@"%@", groups.groupDescription]];
		}
				
		listContent = [[NSArray arrayWithArray:newArray] retain];
		[newArray removeAllObjects];
	}
	
	// create our filtered list that will be the data source of our table, start its content from the master "listContent"
	groupListContent = [[NSMutableArray alloc] initWithCapacity: [listContent count]];
	[groupListContent addObjectsFromArray: listContent];
	[groupListContent retain];
	
	// this stored the current list in case the user cancels the filtering
	savedContent = [[NSMutableArray alloc] initWithCapacity: [listContent count]];
#endif
	
}

#pragma mark UIViewController

- (void)viewWillAppear:(BOOL)animated
{	
	NSIndexPath *tableSelection = [myTableView indexPathForSelectedRow];
	[myTableView deselectRowAtIndexPath:tableSelection animated:NO];
	[myTableView reloadData];
}

// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
- (void)viewDidLoad {
	
	// Use the delegate to set/get values
	appDelegate = (PSAAppDelegate *)[[UIApplication sharedApplication] delegate];
	
	// Set the background color to a nice blue image
	[self.view setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@"PSA_Blue.png"]]];
	[self.myTableView setBackgroundColor:[UIColor clearColor]];
	
	// don't get in the way of user typing
	mySearchBar.autocorrectionType = UITextAutocorrectionTypeNo;
	mySearchBar.autocapitalizationType = UITextAutocapitalizationTypeNone;
	mySearchBar.showsCancelButton = NO;
	mySearchBar.delegate = self;
	
	// Load the client list from the database
	[appDelegate loadGroups];
	
	// create the group list
	if ([appDelegate.groups count] == 0)
		listContent = [[NSArray alloc] initWithObjects:	@"No Group Entries", nil];
		
	[super viewDidLoad];
}

#pragma mark TableViewDelegate

- (UITableViewCell *)tableView:(UITableView *)aTableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [myTableView dequeueReusableCellWithIdentifier:@"TypeCell"];
    if (cell == nil) {
        cell = [[[UITableViewCell alloc] initWithFrame:CGRectZero reuseIdentifier:@"TypeCell"] autorelease];
    }
	
	// Load up the cell type values
	cell.textLabel.textColor = [UIColor blackColor];
	cell.textLabel.font = [UIFont italicSystemFontOfSize:16];
	cell.textLabel.textAlignment = UITextAlignmentLeft;
	cell.accessoryType = UITableViewCellSelectionStyleNone; //UITableViewCellAccessoryDisclosureIndicator;
	
	if ([appDelegate.groups count] == 0) {
		cell.textLabel.textColor = [UIColor lightGrayColor];
		cell.textLabel.font = [UIFont boldSystemFontOfSize:16];
		cell.textLabel.textAlignment = UITextAlignmentCenter;
	}
		
	NSString *serviceName = @"";
	Service *serv;
	
	// Load the group values from the database (we need this for later)
	[appDelegate loadGroups];
	
	groups = [appDelegate.groups objectAtIndex:indexPath.section];
	[appDelegate loadServicesFromGroup:groups.groupID];
	
	for (int i = 0; i < [appDelegate.services count]; i++) {
		serv = [appDelegate.services objectAtIndex:indexPath.row];
		serviceName = [NSString stringWithFormat:@"%@", serv.serviceName];
		cell.textLabel.text = [NSString stringWithFormat:@"%@", serviceName];
	}
		
	return cell;
}

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tv {
	// Load the group values from the database
	[appDelegate loadGroups];
	
	// One for each group the is defined
	return [appDelegate.groups count];
}

- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section {
	// Load the group values from the database
	[appDelegate loadGroups];
	groups = [appDelegate.groups objectAtIndex:section];
	
	return [NSString stringWithFormat:@"%@", groups.groupDescription];
}

// The table has one row for each possible type.
- (NSInteger)tableView:(UITableView *)aTableView numberOfRowsInSection:(NSInteger)section {
	// Load the group values from the database (we need this for later)
	[appDelegate loadGroups];
	
	groups = [appDelegate.groups objectAtIndex:section];
	[appDelegate loadServicesFromGroup:groups.groupID];
	NSInteger numRows = [appDelegate.services count];
	
	if (numRows == 0)
		numRows = 1;
		
	return numRows;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{		
	// don't keep the table selection
	[tableView deselectRowAtIndexPath:indexPath animated:YES];
	
	// Load the group values from the database (we need this for later)
	[appDelegate loadGroups];
	
	groups = [appDelegate.groups objectAtIndex:indexPath.section];
	[appDelegate loadServicesFromGroup:groups.groupID];
	
	Service *serv = [appDelegate.services objectAtIndex:indexPath.row];
	appDelegate.serviceName = serv.serviceName;
	appDelegate.serviceID = serv.serviceID;
	
	[self.view removeFromSuperview];
	[apptController viewWillAppear:YES];
	[rdControl viewWillAppear:YES];
}

- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath {
	return UITableViewCellEditingStyleDelete;
}

- (void)tableView:(UITableView *)tv commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
    // If row is deleted, remove it from the list.	
    if (editingStyle == UITableViewCellEditingStyleDelete) {
        // Find the book at the deleted row, and remove from application delegate's array.
		// Load the group values from the database (we need this for later)
		[appDelegate loadGroups];
		
		groups = [appDelegate.groups objectAtIndex:indexPath.section];
		[appDelegate loadServicesFromGroup:groups.groupID];
		
		if ([appDelegate.services count] == 0) {
			// Delete the Group
			[appDelegate removeGroup:groups.groupID];
			[self.myTableView reloadData];
		} else {
			// Delete the service
			Service *serv = [appDelegate.services objectAtIndex:indexPath.row];
			[appDelegate removeService:serv.serviceID];
			[self.myTableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];
		}
    }
}

#pragma mark UISearchBarDelegate

- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar
{
	// only show the status bar's cancel button while in edit mode
	mySearchBar.showsCancelButton = YES;
	
	// flush and save the current list content in case the user cancels the search later
	[savedContent removeAllObjects];
	[savedContent addObjectsFromArray: groupListContent];
}

- (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar
{
	mySearchBar.showsCancelButton = NO;
}

- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText
{
	//[groupListContent removeAllObjects];	// clear the filtered array first
	
	// search the table content for cell titles that match "searchText"
	// if found add to the mutable array and force the table to reload
	//
	NSString *cellTitle;
	for (cellTitle in listContent)
	{
		NSComparisonResult result = [cellTitle compare:searchText options:NSCaseInsensitiveSearch range:NSMakeRange(0, [searchText length])];
		if (result == NSOrderedSame)
		{
			//[groupListContent addObject:cellTitle];
		}
	}
	
	[myTableView reloadData];
}

// called when cancel button pressed
- (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar
{
	// if a valid search was entered but the user wanted to cancel, bring back the saved list content
	if (searchBar.text.length > 0)
	{
		//[groupListContent removeAllObjects];
		//[groupListContent addObjectsFromArray: savedContent];
	}
	
	[myTableView reloadData];
	
	[searchBar resignFirstResponder];
	searchBar.text = @"";
}

// called when Search (in our case "Done") button pressed
- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar
{
	[searchBar resignFirstResponder];
}


#pragma mark Generic System Methods

// Override to allow orientations other than the default portrait orientation.
- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation {
    // Return YES for supported orientations
    return (interfaceOrientation == UIInterfaceOrientationPortrait);
}


- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning]; // Releases the view if it doesn't have a superview
    // Release anything that's not essential, such as cached data
}

- (void)dealloc {
	[myTableView release];
	[mySearchBar release];
	
	[listContent release];
	//[groupListContent release];
	[savedContent release];
	
    [super dealloc];
}

@end

