//
//  ProductViewController.m
//  PSA
//
//  Created by Michael Simone on 7/20/09.
//  Copyright 2009 Dropped Pin. All rights reserved.
//

#import "ProductViewController.h"
#import "Type.h"
#import "Product.h"

@implementation ProductViewController

@synthesize listContent, filteredListContent, savedContent;
@synthesize myTableView, mySearchBar;
@synthesize appDelegate, detailController, prodTypes, apptController, rdControl;

static ProductViewController *_sharedProductViewController = nil;

+ (ProductViewController *) ProductViewSharedController
{
    if (!_sharedProductViewController)
        _sharedProductViewController = [[[self class] alloc] init];
    return _sharedProductViewController;
}

- (IBAction)cancel:(id)sender {
	[self.view removeFromSuperview];
}

- (IBAction)addProduct:(id)sender {
	// Load the addClient NIB file
	if (detailController == nil) {
		detailController = [[ProductDetailController alloc] initWithNibName:@"ProductDetailView" bundle:[NSBundle mainBundle]];
		detailController.productController = self;
	}
	
	[self.view addSubview:detailController.view];
}

#pragma mark UIViewController

- (void)viewWillAppear:(BOOL)animated
{	
	NSIndexPath *tableSelection = [myTableView indexPathForSelectedRow];
	[myTableView deselectRowAtIndexPath:tableSelection animated:NO];
	[myTableView reloadData];
}

// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
- (void)viewDidLoad {
	
	// Use the delegate to set/get values
	appDelegate = (PSAAppDelegate *)[[UIApplication sharedApplication] delegate];
	
	// Set the background color to a nice blue image
	[self.view setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@"PSA_Blue.png"]]];
	[self.myTableView setBackgroundColor:[UIColor clearColor]];
	
	// don't get in the way of user typing
	mySearchBar.autocorrectionType = UITextAutocorrectionTypeNo;
	mySearchBar.autocapitalizationType = UITextAutocapitalizationTypeNone;
	mySearchBar.showsCancelButton = NO;
	mySearchBar.delegate = self;
	
	// Load the client list from the database
	[appDelegate loadProductTypes];
	
	// create the group list
	if ([appDelegate.productTypes count] == 0)
		listContent = [[NSArray alloc] initWithObjects:	@"No Product Entries", nil];
	
	[super viewDidLoad];
}

#pragma mark TableViewDelegate

- (UITableViewCell *)tableView:(UITableView *)aTableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [myTableView dequeueReusableCellWithIdentifier:@"TypeCell"];
    if (cell == nil) {
        cell = [[[UITableViewCell alloc] initWithFrame:CGRectZero reuseIdentifier:@"TypeCell"] autorelease];
    }
	
	// Load up the cell type values
	cell.textLabel.textColor = [UIColor blackColor];
	cell.textLabel.font = [UIFont italicSystemFontOfSize:16];
	cell.textLabel.textAlignment = UITextAlignmentLeft;
	cell.accessoryType = UITableViewCellSelectionStyleNone; //UITableViewCellAccessoryDisclosureIndicator;
	
	if ([appDelegate.productTypes count] == 0) {
		cell.textLabel.textColor = [UIColor lightGrayColor];
		cell.textLabel.font = [UIFont boldSystemFontOfSize:16];
		cell.textLabel.textAlignment = UITextAlignmentCenter;
	}
	
	NSString *productName = @"";
	Product *prod;
	
	// Load the group values from the database (we need this for later)
	[appDelegate loadProductTypes];
	
	prodTypes = [appDelegate.productTypes objectAtIndex:indexPath.section];
	[appDelegate loadProducts:prodTypes.productID];
	
	for (int i = 0; i < [appDelegate.products count]; i++) {
		prod = [appDelegate.products objectAtIndex:indexPath.row];
		productName = [NSString stringWithFormat:@"%@", prod.productName];
		cell.textLabel.text = [NSString stringWithFormat:@"%@", productName];
	}
	
	return cell;
}

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tv {
	// Load the group values from the database
	[appDelegate loadProductTypes];
	
	// One for each group the is defined
	return [appDelegate.productTypes count];
}

- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section {
	// Load the group values from the database
	[appDelegate loadProductTypes];
	prodTypes = [appDelegate.productTypes objectAtIndex:section];
	
	return [NSString stringWithFormat:@"%@", prodTypes.productDescription];
}

// The table has one row for each possible type.
- (NSInteger)tableView:(UITableView *)aTableView numberOfRowsInSection:(NSInteger)section {
	// Load the group values from the database (we need this for later)
	[appDelegate loadProductTypes];
	
	prodTypes = [appDelegate.productTypes objectAtIndex:section];
	[appDelegate loadProducts:prodTypes.productID];
	NSInteger numRows = [appDelegate.products count];
	
	if (numRows == 0)
		numRows = 1;
	
	return numRows;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{		
	// don't keep the table selection
	[tableView deselectRowAtIndexPath:indexPath animated:YES];
	
	// Load the group values from the database (we need this for later)
	[appDelegate loadProductTypes];
	
	prodTypes = [appDelegate.productTypes objectAtIndex:indexPath.section];
	[appDelegate loadProducts:prodTypes.productID];
	
	Product *prod = [appDelegate.products objectAtIndex:indexPath.row];
	appDelegate.productName = prod.productName;
	appDelegate.productID = prod.productID;
	
	[self.view removeFromSuperview];
	[apptController viewWillAppear:YES];
	[rdControl viewWillAppear:YES];
}

- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath {
	return UITableViewCellEditingStyleDelete;
}

- (void)tableView:(UITableView *)tv commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
    // If row is deleted, remove it from the list.	
    if (editingStyle == UITableViewCellEditingStyleDelete) {
        // Find the book at the deleted row, and remove from application delegate's array.
		// Load the group values from the database (we need this for later)
		[appDelegate loadProductTypes];
		
		prodTypes = [appDelegate.productTypes objectAtIndex:indexPath.section];
		[appDelegate loadProducts:prodTypes.productID];
		
		if ([appDelegate.products count] == 0) {
			// Delete the actual product type
			[appDelegate removeProductType:prodTypes.productID];
			[self.myTableView reloadData];
		} else {
			// Delete the product
			Product *prod = [appDelegate.products objectAtIndex:indexPath.row];
			[appDelegate removeProduct:prod.productID];
			// Animate the deletion from the table.
			[self.myTableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];
		}
    }
}

#pragma mark UISearchBarDelegate

- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar
{
	// only show the status bar's cancel button while in edit mode
	mySearchBar.showsCancelButton = YES;
	
	// flush and save the current list content in case the user cancels the search later
	[savedContent removeAllObjects];
	[savedContent addObjectsFromArray: filteredListContent];
}

- (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar
{
	mySearchBar.showsCancelButton = NO;
}

- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText
{
	[filteredListContent removeAllObjects];	// clear the filtered array first
	
	// search the table content for cell titles that match "searchText"
	// if found add to the mutable array and force the table to reload
	//
	NSString *cellTitle;
	for (cellTitle in listContent)
	{
		NSComparisonResult result = [cellTitle compare:searchText options:NSCaseInsensitiveSearch 
												 range:NSMakeRange(0, [searchText length])];
		if (result == NSOrderedSame)
		{
			[filteredListContent addObject:cellTitle];
		}
	}
	
	[myTableView reloadData];
}

// called when cancel button pressed
- (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar
{
	// if a valid search was entered but the user wanted to cancel, bring back the saved list content
	if (searchBar.text.length > 0)
	{
		[filteredListContent removeAllObjects];
		[filteredListContent addObjectsFromArray: savedContent];
	}
	
	[myTableView reloadData];
	
	[searchBar resignFirstResponder];
	searchBar.text = @"";
}

// called when Search (in our case "Done") button pressed
- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar
{
	[searchBar resignFirstResponder];
}


#pragma mark Generic System Methods

// Override to allow orientations other than the default portrait orientation.
- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation {
    // Return YES for supported orientations
    return (interfaceOrientation == UIInterfaceOrientationPortrait);
}

- (void)didReceiveMemoryWarning {
	// Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];
	
	// Release any cached data, images, etc that aren't in use.
}

- (void)viewDidUnload {
	// Release any retained subviews of the main view.
	// e.g. self.myOutlet = nil;
}


- (void)dealloc {
    [super dealloc];
}


@end
